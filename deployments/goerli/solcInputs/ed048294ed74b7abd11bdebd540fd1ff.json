{
  "language": "Solidity",
  "sources": {
    "contracts/abaci.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// abaci.sol -- price decrease functions for auctions\n\n// Copyright (C) 2020-2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\ninterface Abacus {\n    // 1st arg: initial price               [ray]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price       [ray]\n    function price(uint256, uint256) external view returns (uint256);\n}\n\ncontract LinearDecrease is Abacus {\n\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"LinearDecrease/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    uint256 public tau;  // Seconds after auction start when the price reaches zero [seconds]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n\n    // --- Init ---\n    constructor() public {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth {\n        if (what ==  \"tau\") tau = data;\n        else revert(\"LinearDecrease/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Math ---\n    uint256 constant RAY = 10 ** 27;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / RAY;\n    }\n\n    // Price calculation when price is decreased linearly in proportion to time:\n    // tau: The number of seconds after the start of the auction where the price will hit 0\n    // top: Initial price\n    // dur: current seconds since the start of the auction\n    //\n    // Returns y = top * ((tau - dur) / tau)\n    //\n    // Note the internal call to mul multiples by RAY, thereby ensuring that the rmul calculation\n    // which utilizes top and tau (RAY values) is also a RAY value.\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\n        if (dur >= tau) return 0;\n        return rmul(top, mul(tau - dur, RAY) / tau);\n    }\n}\n\ncontract StairstepExponentialDecrease is Abacus {\n\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"StairstepExponentialDecrease/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    uint256 public step; // Length of time between price drops [seconds]\n    uint256 public cut;  // Per-step multiplicative factor     [ray]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n\n    // --- Init ---\n    // @notice: `cut` and `step` values must be correctly set for\n    //     this contract to return a valid price\n    constructor() public {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth {\n        if      (what ==  \"cut\") require((cut = data) <= RAY, \"StairstepExponentialDecrease/cut-gt-RAY\");\n        else if (what == \"step\") step = data;\n        else revert(\"StairstepExponentialDecrease/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Math ---\n    uint256 constant RAY = 10 ** 27;\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / RAY;\n    }\n    // optimized version from dss PR #78\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\n        assembly {\n            switch n case 0 { z := b }\n            default {\n                switch x case 0 { z := 0 }\n                default {\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\n                    let half := div(b, 2)  // for rounding.\n                    for { n := div(n, 2) } n { n := div(n,2) } {\n                        let xx := mul(x, x)\n                        if shr(128, x) { revert(0,0) }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) { revert(0,0) }\n                        x := div(xxRound, b)\n                        if mod(n,2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) { revert(0,0) }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // top: initial price\n    // dur: seconds since the auction has started\n    // step: seconds between a price drop\n    // cut: cut encodes the percentage to decrease per step.\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\n    //   So, for a 1% decrease per step, cut would be (1 - 0.01) * RAY\n    //\n    // returns: top * (cut ^ dur)\n    //\n    //\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\n        return rmul(top, rpow(cut, dur / step, RAY));\n    }\n}\n\n// While an equivalent function can be obtained by setting step = 1 in StairstepExponentialDecrease,\n// this continous (i.e. per-second) exponential decrease has be implemented as it is more gas-efficient\n// than using the stairstep version with step = 1 (primarily due to 1 fewer SLOAD per price calculation).\ncontract ExponentialDecrease is Abacus {\n\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"ExponentialDecrease/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    uint256 public cut;  // Per-second multiplicative factor [ray]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n\n    // --- Init ---\n    // @notice: `cut` value must be correctly set for\n    //     this contract to return a valid price\n    constructor() public {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth {\n        if      (what ==  \"cut\") require((cut = data) <= RAY, \"ExponentialDecrease/cut-gt-RAY\");\n        else revert(\"ExponentialDecrease/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Math ---\n    uint256 constant RAY = 10 ** 27;\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / RAY;\n    }\n    // optimized version from dss PR #78\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\n        assembly {\n            switch n case 0 { z := b }\n            default {\n                switch x case 0 { z := 0 }\n                default {\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\n                    let half := div(b, 2)  // for rounding.\n                    for { n := div(n, 2) } n { n := div(n,2) } {\n                        let xx := mul(x, x)\n                        if shr(128, x) { revert(0,0) }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) { revert(0,0) }\n                        x := div(xxRound, b)\n                        if mod(n,2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) { revert(0,0) }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // top: initial price\n    // dur: seconds since the auction has started\n    // cut: cut encodes the percentage to decrease per second.\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\n    //   So, for a 1% decrease per second, cut would be (1 - 0.01) * RAY\n    //\n    // returns: top * (cut ^ dur)\n    //\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\n        return rmul(top, rpow(cut, dur, RAY));\n    }\n}\n"
    },
    "contracts/cat.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// cat.sol -- Dai liquidation module\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface Kicker {\n    function kick(address urn, address gal, uint256 tab, uint256 lot, uint256 bid)\n        external returns (uint256);\n}\n\ninterface VatLike {\n    function ilks(bytes32) external view returns (\n        uint256 Art,  // [wad]\n        uint256 rate, // [ray]\n        uint256 spot, // [ray]\n        uint256 line, // [rad]\n        uint256 dust  // [rad]\n    );\n    function urns(bytes32,address) external view returns (\n        uint256 ink,  // [wad]\n        uint256 art   // [wad]\n    );\n    function grab(bytes32,address,address,address,int256,int256) external;\n    function hope(address) external;\n    function nope(address) external;\n}\n\ninterface VowLike {\n    function fess(uint256) external;\n}\n\ncontract Cat {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Cat/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        address flip;  // Liquidator\n        uint256 chop;  // Liquidation Penalty  [wad]\n        uint256 dunk;  // Liquidation Quantity [rad]\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    uint256 public live;   // Active Flag\n    VatLike public vat;    // CDP Engine\n    VowLike public vow;    // Debt Engine\n    uint256 public box;    // Max Dai out for liquidation        [rad]\n    uint256 public litter; // Balance of Dai out for liquidation [rad]\n\n    // --- Events ---\n    event Bite(\n      bytes32 indexed ilk,\n      address indexed urn,\n      uint256 ink,\n      uint256 art,\n      uint256 tab,\n      address flip,\n      uint256 id\n    );\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        live = 1;\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        if (x > y) { z = y; } else { z = x; }\n    }\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) external auth {\n        if (what == \"vow\") vow = VowLike(data);\n        else revert(\"Cat/file-unrecognized-param\");\n    }\n    function file(bytes32 what, uint256 data) external auth {\n        if (what == \"box\") box = data;\n        else revert(\"Cat/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        if (what == \"chop\") ilks[ilk].chop = data;\n        else if (what == \"dunk\") ilks[ilk].dunk = data;\n        else revert(\"Cat/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, address flip) external auth {\n        if (what == \"flip\") {\n            vat.nope(ilks[ilk].flip);\n            ilks[ilk].flip = flip;\n            vat.hope(flip);\n        }\n        else revert(\"Cat/file-unrecognized-param\");\n    }\n\n    // --- CDP Liquidation ---\n    function bite(bytes32 ilk, address urn) external returns (uint256 id) {\n        (,uint256 rate,uint256 spot,,uint256 dust) = vat.ilks(ilk);\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n\n        require(live == 1, \"Cat/not-live\");\n        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\n\n        Ilk memory milk = ilks[ilk];\n        uint256 dart;\n        {\n            uint256 room = sub(box, litter);\n\n            // test whether the remaining space in the litterbox is dusty\n            require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\n\n            dart = min(art, mul(min(milk.dunk, room), WAD) / rate / milk.chop);\n        }\n\n        uint256 dink = min(ink, mul(ink, dart) / art);\n\n        require(dart >  0      && dink >  0     , \"Cat/null-auction\");\n        require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\n\n        // This may leave the CDP in a dusty state\n        vat.grab(\n            ilk, urn, address(this), address(vow), -int256(dink), -int256(dart)\n        );\n        vow.fess(mul(dart, rate));\n\n        { // Avoid stack too deep\n            // This calcuation will overflow if dart*rate exceeds ~10^14,\n            // i.e. the maximum dunk is roughly 100 trillion DAI.\n            uint256 tab = mul(mul(dart, rate), milk.chop) / WAD;\n            litter = add(litter, tab);\n\n            id = Kicker(milk.flip).kick({\n                urn: urn,\n                gal: address(vow),\n                tab: tab,\n                lot: dink,\n                bid: 0\n            });\n        }\n\n        emit Bite(ilk, urn, dink, dart, mul(dart, rate), milk.flip, id);\n    }\n\n    function claw(uint256 rad) external auth {\n        litter = sub(litter, rad);\n    }\n\n    function cage() external auth {\n        live = 0;\n    }\n}\n"
    },
    "contracts/clip.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// clip.sol -- Dai auction module 2.0\n\n// Copyright (C) 2020-2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\ninterface VatLike {\n    function move(address,address,uint256) external;\n    function flux(bytes32,address,address,uint256) external;\n    function ilks(bytes32) external returns (uint256, uint256, uint256, uint256, uint256);\n    function suck(address,address,uint256) external;\n}\n\ninterface PipLike {\n    function peek() external returns (bytes32, bool);\n}\n\ninterface SpotterLike {\n    function par() external returns (uint256);\n    function ilks(bytes32) external returns (PipLike, uint256);\n}\n\ninterface DogLike {\n    function chop(bytes32) external returns (uint256);\n    function digs(bytes32, uint256) external;\n}\n\ninterface ClipperCallee {\n    function clipperCall(address, uint256, uint256, bytes calldata) external;\n}\n\ninterface AbacusLike {\n    function price(uint256, uint256) external view returns (uint256);\n}\n\ncontract Clipper {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Clipper/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    bytes32  immutable public ilk;   // Collateral type of this Clipper\n    VatLike  immutable public vat;   // Core CDP Engine\n\n    DogLike     public dog;      // Liquidation module\n    address     public vow;      // Recipient of dai raised in auctions\n    SpotterLike public spotter;  // Collateral price module\n    AbacusLike  public calc;     // Current price calculator\n\n    uint256 public buf;    // Multiplicative factor to increase starting price                  [ray]\n    uint256 public tail;   // Time elapsed before auction reset                                 [seconds]\n    uint256 public cusp;   // Percentage drop before auction reset                              [ray]\n    uint64  public chip;   // Percentage of tab to suck from vow to incentivize keepers         [wad]\n    uint192 public tip;    // Flat fee to suck from vow to incentivize keepers                  [rad]\n    uint256 public chost;  // Cache the ilk dust times the ilk chop to prevent excessive SLOADs [rad]\n\n    uint256   public kicks;   // Total auctions\n    uint256[] public active;  // Array of active auction ids\n\n    struct Sale {\n        uint256 pos;  // Index in active array\n        uint256 tab;  // Dai to raise       [rad]\n        uint256 lot;  // collateral to sell [wad]\n        address usr;  // Liquidated CDP\n        uint96  tic;  // Auction start time\n        uint256 top;  // Starting price     [ray]\n    }\n    mapping(uint256 => Sale) public sales;\n\n    uint256 internal locked;\n\n    // Levels for circuit breaker\n    // 0: no breaker\n    // 1: no new kick()\n    // 2: no new kick() or redo()\n    // 3: no new kick(), redo(), or take()\n    uint256 public stopped = 0;\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed what, address data);\n\n    event Kick(\n        uint256 indexed id,\n        uint256 top,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr,\n        address indexed kpr,\n        uint256 coin\n    );\n    event Take(\n        uint256 indexed id,\n        uint256 max,\n        uint256 price,\n        uint256 owe,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr\n    );\n    event Redo(\n        uint256 indexed id,\n        uint256 top,\n        uint256 tab,\n        uint256 lot,\n        address indexed usr,\n        address indexed kpr,\n        uint256 coin\n    );\n\n    event Yank(uint256 id);\n\n    // --- Init ---\n    constructor(address vat_, address spotter_, address dog_, bytes32 ilk_) public {\n        vat     = VatLike(vat_);\n        spotter = SpotterLike(spotter_);\n        dog     = DogLike(dog_);\n        ilk     = ilk_;\n        buf     = RAY;\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Synchronization ---\n    modifier lock {\n        require(locked == 0, \"Clipper/system-locked\");\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    modifier isStopped(uint256 level) {\n        require(stopped < level, \"Clipper/stopped-incorrect\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth lock {\n        if      (what == \"buf\")         buf = data;\n        else if (what == \"tail\")       tail = data;           // Time elapsed before auction reset\n        else if (what == \"cusp\")       cusp = data;           // Percentage drop before auction reset\n        else if (what == \"chip\")       chip = uint64(data);   // Percentage of tab to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\n        else if (what == \"tip\")         tip = uint192(data);  // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T RAD)\n        else if (what == \"stopped\") stopped = data;           // Set breaker (0, 1, 2, or 3)\n        else revert(\"Clipper/file-unrecognized-param\");\n        emit File(what, data);\n    }\n    function file(bytes32 what, address data) external auth lock {\n        if (what == \"spotter\") spotter = SpotterLike(data);\n        else if (what == \"dog\")    dog = DogLike(data);\n        else if (what == \"vow\")    vow = data;\n        else if (what == \"calc\")  calc = AbacusLike(data);\n        else revert(\"Clipper/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Math ---\n    uint256 constant BLN = 10 **  9;\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = mul(x, y) / WAD;\n    }\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = mul(x, y) / RAY;\n    }\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = mul(x, RAY) / y;\n    }\n\n    // --- Auction ---\n\n    // get the price directly from the OSM\n    // Could get this from rmul(Vat.ilks(ilk).spot, Spotter.mat()) instead, but\n    // if mat has changed since the last poke, the resulting value will be\n    // incorrect.\n    function getFeedPrice() internal returns (uint256 feedPrice) {\n        (PipLike pip, ) = spotter.ilks(ilk);\n        (bytes32 val, bool has) = pip.peek();\n        require(has, \"Clipper/invalid-price\");\n        feedPrice = rdiv(mul(uint256(val), BLN), spotter.par());\n    }\n\n    // start an auction\n    // note: trusts the caller to transfer collateral to the contract\n    // The starting price `top` is obtained as follows:\n    //\n    //     top = val * buf / par\n    //\n    // Where `val` is the collateral's unitary value in USD, `buf` is a\n    // multiplicative factor to increase the starting price, and `par` is a\n    // reference per DAI.\n    function kick(\n        uint256 tab,  // Debt                   [rad]\n        uint256 lot,  // Collateral             [wad]\n        address usr,  // Address that will receive any leftover collateral\n        address kpr   // Address that will receive incentives\n    ) external auth lock isStopped(1) returns (uint256 id) {\n        // Input validation\n        require(tab  >          0, \"Clipper/zero-tab\");\n        require(lot  >          0, \"Clipper/zero-lot\");\n        require(usr != address(0), \"Clipper/zero-usr\");\n        id = ++kicks;\n        require(id   >          0, \"Clipper/overflow\");\n\n        active.push(id);\n\n        sales[id].pos = active.length - 1;\n\n        sales[id].tab = tab;\n        sales[id].lot = lot;\n        sales[id].usr = usr;\n        sales[id].tic = uint96(block.timestamp);\n\n        uint256 top;\n        top = rmul(getFeedPrice(), buf);\n        require(top > 0, \"Clipper/zero-top-price\");\n        sales[id].top = top;\n\n        // incentive to kick auction\n        uint256 _tip  = tip;\n        uint256 _chip = chip;\n        uint256 coin;\n        if (_tip > 0 || _chip > 0) {\n            coin = add(_tip, wmul(tab, _chip));\n            vat.suck(vow, kpr, coin);\n        }\n\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\n    }\n\n    // Reset an auction\n    // See `kick` above for an explanation of the computation of `top`.\n    function redo(\n        uint256 id,  // id of the auction to reset\n        address kpr  // Address that will receive incentives\n    ) external lock isStopped(2) {\n        // Read auction data\n        address usr = sales[id].usr;\n        uint96  tic = sales[id].tic;\n        uint256 top = sales[id].top;\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n        // Check that auction needs reset\n        // and compute current price [ray]\n        (bool done,) = status(tic, top);\n        require(done, \"Clipper/cannot-reset\");\n\n        uint256 tab   = sales[id].tab;\n        uint256 lot   = sales[id].lot;\n        sales[id].tic = uint96(block.timestamp);\n\n        uint256 feedPrice = getFeedPrice();\n        top = rmul(feedPrice, buf);\n        require(top > 0, \"Clipper/zero-top-price\");\n        sales[id].top = top;\n\n        // incentive to redo auction\n        uint256 _tip  = tip;\n        uint256 _chip = chip;\n        uint256 coin;\n        if (_tip > 0 || _chip > 0) {\n            uint256 _chost = chost;\n            if (tab >= _chost && mul(lot, feedPrice) >= _chost) {\n                coin = add(_tip, wmul(tab, _chip));\n                vat.suck(vow, kpr, coin);\n            }\n        }\n\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\n    }\n\n    // Buy up to `amt` of collateral from the auction indexed by `id`.\n    // \n    // Auctions will not collect more DAI than their assigned DAI target,`tab`;\n    // thus, if `amt` would cost more DAI than `tab` at the current price, the\n    // amount of collateral purchased will instead be just enough to collect `tab` DAI.\n    //\n    // To avoid partial purchases resulting in very small leftover auctions that will\n    // never be cleared, any partial purchase must leave at least `Clipper.chost`\n    // remaining DAI target. `chost` is an asynchronously updated value equal to\n    // (Vat.dust * Dog.chop(ilk) / WAD) where the values are understood to be determined\n    // by whatever they were when Clipper.upchost() was last called. Purchase amounts\n    // will be minimally decreased when necessary to respect this limit; i.e., if the\n    // specified `amt` would leave `tab < chost` but `tab > 0`, the amount actually\n    // purchased will be such that `tab == chost`.\n    //\n    // If `tab <= chost`, partial purchases are no longer possible; that is, the remaining\n    // collateral can only be purchased entirely, or not at all.\n    function take(\n        uint256 id,           // Auction id\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\n        address who,          // Receiver of collateral and external call address\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\n    ) external lock isStopped(3) {\n\n        address usr = sales[id].usr;\n        uint96  tic = sales[id].tic;\n\n        require(usr != address(0), \"Clipper/not-running-auction\");\n\n        uint256 price;\n        {\n            bool done;\n            (done, price) = status(tic, sales[id].top);\n\n            // Check that auction doesn't need reset\n            require(!done, \"Clipper/needs-reset\");\n        }\n\n        // Ensure price is acceptable to buyer\n        require(max >= price, \"Clipper/too-expensive\");\n\n        uint256 lot = sales[id].lot;\n        uint256 tab = sales[id].tab;\n        uint256 owe;\n\n        {\n            // Purchase as much as possible, up to amt\n            uint256 slice = min(lot, amt);  // slice <= lot\n\n            // DAI needed to buy a slice of this sale\n            owe = mul(slice, price);\n\n            // Don't collect more than tab of DAI\n            if (owe > tab) {\n                // Total debt will be paid\n                owe = tab;                  // owe' <= owe\n                // Adjust slice\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\n            } else if (owe < tab && slice < lot) {\n                // If slice == lot => auction completed => dust doesn't matter\n                uint256 _chost = chost;\n                if (tab - owe < _chost) {    // safe as owe < tab\n                    // If tab <= chost, buyers have to take the entire lot.\n                    require(tab > _chost, \"Clipper/no-partial-purchase\");\n                    // Adjust amount to pay\n                    owe = tab - _chost;      // owe' <= owe\n                    // Adjust slice\n                    slice = owe / price;     // slice' = owe' / price < owe / price == slice < lot\n                }\n            }\n\n            // Calculate remaining tab after operation\n            tab = tab - owe;  // safe since owe <= tab\n            // Calculate remaining lot after operation\n            lot = lot - slice;\n\n            // Send collateral to who\n            vat.flux(ilk, address(this), who, slice);\n\n            // Do external call (if data is defined) but to be\n            // extremely careful we don't allow to do it to the two\n            // contracts which the Clipper needs to be authorized\n            DogLike dog_ = dog;\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\n            }\n\n            // Get DAI from caller\n            vat.move(msg.sender, vow, owe);\n\n            // Removes Dai out for liquidation from accumulator\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\n        }\n\n        if (lot == 0) {\n            _remove(id);\n        } else if (tab == 0) {\n            vat.flux(ilk, address(this), usr, lot);\n            _remove(id);\n        } else {\n            sales[id].tab = tab;\n            sales[id].lot = lot;\n        }\n\n        emit Take(id, max, price, owe, tab, lot, usr);\n    }\n\n    function _remove(uint256 id) internal {\n        uint256 _move    = active[active.length - 1];\n        if (id != _move) {\n            uint256 _index   = sales[id].pos;\n            active[_index]   = _move;\n            sales[_move].pos = _index;\n        }\n        active.pop();\n        delete sales[id];\n    }\n\n    // The number of active auctions\n    function count() external view returns (uint256) {\n        return active.length;\n    }\n\n    // Return the entire array of active auctions\n    function list() external view returns (uint256[] memory) {\n        return active;\n    }\n\n    // Externally returns boolean for if an auction needs a redo and also the current price\n    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price, uint256 lot, uint256 tab) {\n        // Read auction data\n        address usr = sales[id].usr;\n        uint96  tic = sales[id].tic;\n\n        bool done;\n        (done, price) = status(tic, sales[id].top);\n\n        needsRedo = usr != address(0) && done;\n        lot = sales[id].lot;\n        tab = sales[id].tab;\n    }\n\n    // Internally returns boolean for if an auction needs a redo\n    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\n        price = calc.price(top, sub(block.timestamp, tic));\n        done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp);\n    }\n\n    // Public function to update the cached dust*chop value.\n    function upchost() external {\n        (,,,, uint256 _dust) = VatLike(vat).ilks(ilk);\n        chost = wmul(_dust, dog.chop(ilk));\n    }\n\n    // Cancel an auction during ES or via governance action.\n    function yank(uint256 id) external auth lock {\n        require(sales[id].usr != address(0), \"Clipper/not-running-auction\");\n        dog.digs(ilk, sales[id].tab);\n        vat.flux(ilk, address(this), msg.sender, sales[id].lot);\n        _remove(id);\n        emit Yank(id);\n    }\n}\n"
    },
    "contracts/cure.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// cure.sol -- Debt Rectifier contract\n\n// Copyright (C) 2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.12;\n\ninterface SourceLike {\n    function cure() external view returns (uint256);\n}\n\ncontract Cure {\n    mapping (address => uint256) public wards;\n    uint256 public live;\n    address[] public srcs;\n    uint256 public wait;\n    uint256 public when;\n    mapping (address => uint256) public pos; // position in srcs + 1, 0 means a source does not exist\n    mapping (address => uint256) public amt;\n    mapping (address => uint256) public loaded;\n    uint256 public lCount;\n    uint256 public say;\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event File(bytes32 indexed what, uint256 data);\n    event Lift(address indexed src);\n    event Drop(address indexed src);\n    event Load(address indexed src);\n    event Cage();\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Cure/not-authorized\");\n        _;\n    }\n\n    // --- Internal ---\n    function _add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"Cure/add-overflow\");\n    }\n\n    function _sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"Cure/sub-underflow\");\n    }\n\n    constructor() public {\n        live = 1;\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function tCount() external view returns (uint256 count_) {\n        count_ = srcs.length;\n    }\n\n    function list() external view returns (address[] memory) {\n        return srcs;\n    }\n\n    function tell() external view returns (uint256) {\n        require(live == 0 && (lCount == srcs.length || block.timestamp >= when), \"Cure/missing-load-and-time-not-passed\");\n        return say;\n    }\n\n    function rely(address usr) external auth {\n        require(live == 1, \"Cure/not-live\");\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        require(live == 1, \"Cure/not-live\");\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Cure/not-live\");\n        if (what == \"wait\") wait = data;\n        else revert(\"Cure/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function lift(address src) external auth {\n        require(live == 1, \"Cure/not-live\");\n        require(pos[src] == 0, \"Cure/already-existing-source\");\n        srcs.push(src);\n        pos[src] = srcs.length;\n        emit Lift(src);\n    }\n\n    function drop(address src) external auth {\n        require(live == 1, \"Cure/not-live\");\n        uint256 pos_ = pos[src];\n        require(pos_ > 0, \"Cure/non-existing-source\");\n        uint256 last = srcs.length;\n        if (pos_ < last) {\n            address move = srcs[last - 1];\n            srcs[pos_ - 1] = move;\n            pos[move] = pos_;\n        }\n        srcs.pop();\n        delete pos[src];\n        delete amt[src];\n        emit Drop(src);\n    }\n\n    function cage() external auth {\n        require(live == 1, \"Cure/not-live\");\n        live = 0;\n        when = _add(block.timestamp, wait);\n        emit Cage();\n    }\n\n    function load(address src) external {\n        require(live == 0, \"Cure/still-live\");\n        require(pos[src] > 0, \"Cure/non-existing-source\");\n        uint256 oldAmt_ = amt[src];\n        uint256 newAmt_ = amt[src] = SourceLike(src).cure();\n        say = _add(_sub(say, oldAmt_), newAmt_);\n        if (loaded[src] == 0) {\n            loaded[src] = 1;\n            lCount++;\n        }\n        emit Load(src);\n    }\n}\n"
    },
    "contracts/dai.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// dai.sol -- Dai Stablecoin ERC-20 Token\n\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract Dai {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external auth { wards[guy] = 1; }\n    function deny(address guy) external auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Dai/not-authorized\");\n        _;\n    }\n\n    // --- ERC20 Data ---\n    string  public constant name     = \"Dai Stablecoin\";\n    string  public constant symbol   = \"DAI\";\n    string  public constant version  = \"1\";\n    uint8   public constant decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint)                      public nonces;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(uint256 chainId_) public {\n        wards[msg.sender] = 1;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad)\n        public returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function mint(address usr, uint wad) external auth {\n        balanceOf[usr] = add(balanceOf[usr], wad);\n        totalSupply    = add(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n    function burn(address usr, uint wad) external {\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n        }\n        balanceOf[usr] = sub(balanceOf[usr], wad);\n        totalSupply    = sub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n    function approve(address usr, uint wad) external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    // --- Alias ---\n    function push(address usr, uint wad) external {\n        transferFrom(msg.sender, usr, wad);\n    }\n    function pull(address usr, uint wad) external {\n        transferFrom(usr, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) external {\n        transferFrom(src, dst, wad);\n    }\n\n    // --- Approve by signature ---\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        allowance[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}\n"
    },
    "contracts/dog.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// dog.sol -- Dai liquidation module 2.0\n\n// Copyright (C) 2020-2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\ninterface ClipperLike {\n    function ilk() external view returns (bytes32);\n    function kick(\n        uint256 tab,\n        uint256 lot,\n        address usr,\n        address kpr\n    ) external returns (uint256);\n}\n\ninterface VatLike {\n    function ilks(bytes32) external view returns (\n        uint256 Art,  // [wad]\n        uint256 rate, // [ray]\n        uint256 spot, // [ray]\n        uint256 line, // [rad]\n        uint256 dust  // [rad]\n    );\n    function urns(bytes32,address) external view returns (\n        uint256 ink,  // [wad]\n        uint256 art   // [wad]\n    );\n    function grab(bytes32,address,address,address,int256,int256) external;\n    function hope(address) external;\n    function nope(address) external;\n}\n\ninterface VowLike {\n    function fess(uint256) external;\n}\n\ncontract Dog {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Dog/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        address clip;  // Liquidator\n        uint256 chop;  // Liquidation Penalty                                          [wad]\n        uint256 hole;  // Max DAI needed to cover debt+fees of active auctions per ilk [rad]\n        uint256 dirt;  // Amt DAI needed to cover debt+fees of active auctions per ilk [rad]\n    }\n\n    VatLike immutable public vat;  // CDP Engine\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    VowLike public vow;   // Debt Engine\n    uint256 public live;  // Active Flag\n    uint256 public Hole;  // Max DAI needed to cover debt+fees of active auctions [rad]\n    uint256 public Dirt;  // Amt DAI needed to cover debt+fees of active auctions [rad]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed what, address data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, address clip);\n\n    event Bark(\n      bytes32 indexed ilk,\n      address indexed urn,\n      uint256 ink,\n      uint256 art,\n      uint256 due,\n      address clip,\n      uint256 indexed id\n    );\n    event Digs(bytes32 indexed ilk, uint256 rad);\n    event Cage();\n\n    // --- Init ---\n    constructor(address vat_) public {\n        vat = VatLike(vat_);\n        live = 1;\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x <= y ? x : y;\n    }\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) external auth {\n        if (what == \"vow\") vow = VowLike(data);\n        else revert(\"Dog/file-unrecognized-param\");\n        emit File(what, data);\n    }\n    function file(bytes32 what, uint256 data) external auth {\n        if (what == \"Hole\") Hole = data;\n        else revert(\"Dog/file-unrecognized-param\");\n        emit File(what, data);\n    }\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        if (what == \"chop\") {\n            require(data >= WAD, \"Dog/file-chop-lt-WAD\");\n            ilks[ilk].chop = data;\n        } else if (what == \"hole\") ilks[ilk].hole = data;\n        else revert(\"Dog/file-unrecognized-param\");\n        emit File(ilk, what, data);\n    }\n    function file(bytes32 ilk, bytes32 what, address clip) external auth {\n        if (what == \"clip\") {\n            require(ilk == ClipperLike(clip).ilk(), \"Dog/file-ilk-neq-clip.ilk\");\n            ilks[ilk].clip = clip;\n        } else revert(\"Dog/file-unrecognized-param\");\n        emit File(ilk, what, clip);\n    }\n\n    function chop(bytes32 ilk) external view returns (uint256) {\n        return ilks[ilk].chop;\n    }\n\n    // --- CDP Liquidation: all bark and no bite ---\n    //\n    // Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\n    //\n    // The third argument is the address that will receive the liquidation reward, if any.\n    //\n    // The entire Vault will be liquidated except when the target amount of DAI to be raised in\n    // the resulting auction (debt of Vault + liquidation penalty) causes either Dirt to exceed\n    // Hole or ilk.dirt to exceed ilk.hole by an economically significant amount. In that\n    // case, a partial liquidation is performed to respect the global and per-ilk limits on\n    // outstanding DAI target. The one exception is if the resulting auction would likely\n    // have too little collateral to be interesting to Keepers (debt taken from Vault < ilk.dust),\n    // in which case the function reverts. Please refer to the code and comments within if\n    // more detail is desired.\n    function bark(bytes32 ilk, address urn, address kpr) external returns (uint256 id) {\n        require(live == 1, \"Dog/not-live\");\n\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n        Ilk memory milk = ilks[ilk];\n        uint256 dart;\n        uint256 rate;\n        uint256 dust;\n        {\n            uint256 spot;\n            (,rate, spot,, dust) = vat.ilks(ilk);\n            require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Dog/not-unsafe\");\n\n            // Get the minimum value between:\n            // 1) Remaining space in the general Hole\n            // 2) Remaining space in the collateral hole\n            require(Hole > Dirt && milk.hole > milk.dirt, \"Dog/liquidation-limit-hit\");\n            uint256 room = min(Hole - Dirt, milk.hole - milk.dirt);\n\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\n            dart = min(art, mul(room, WAD) / rate / milk.chop);\n\n            // Partial liquidation edge case logic\n            if (art > dart) {\n                if (mul(art - dart, rate) < dust) {\n\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\n                    // This will result in at least one of dirt_i > hole_i or Dirt > Hole becoming true.\n                    // The amount of excess will be bounded above by ceiling(dust_i * chop_i / WAD).\n                    // This deviation is assumed to be small compared to both hole_i and Hole, so that\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\n                    dart = art;\n                } else {\n\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\n                    require(mul(dart, rate) >= dust, \"Dog/dusty-auction-from-partial-liquidation\");\n                }\n            }\n        }\n\n        uint256 dink = mul(ink, dart) / art;\n\n        require(dink > 0, \"Dog/null-auction\");\n        require(dart <= 2**255 && dink <= 2**255, \"Dog/overflow\");\n\n        vat.grab(\n            ilk, urn, milk.clip, address(vow), -int256(dink), -int256(dart)\n        );\n\n        uint256 due = mul(dart, rate);\n        vow.fess(due);\n\n        {   // Avoid stack too deep\n            // This calcuation will overflow if dart*rate exceeds ~10^14\n            uint256 tab = mul(due, milk.chop) / WAD;\n            Dirt = add(Dirt, tab);\n            ilks[ilk].dirt = add(milk.dirt, tab);\n\n            id = ClipperLike(milk.clip).kick({\n                tab: tab,\n                lot: dink,\n                usr: urn,\n                kpr: kpr\n            });\n        }\n\n        emit Bark(ilk, urn, dink, dart, due, milk.clip, id);\n    }\n\n    function digs(bytes32 ilk, uint256 rad) external auth {\n        Dirt = sub(Dirt, rad);\n        ilks[ilk].dirt = sub(ilks[ilk].dirt, rad);\n        emit Digs(ilk, rad);\n    }\n\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n}\n"
    },
    "contracts/end.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// end.sol -- global settlement engine\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n// Copyright (C) 2020-2021 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\ninterface VatLike {\n    function dai(address) external view returns (uint256);\n    function ilks(bytes32 ilk) external returns (\n        uint256 Art,   // [wad]\n        uint256 rate,  // [ray]\n        uint256 spot,  // [ray]\n        uint256 line,  // [rad]\n        uint256 dust   // [rad]\n    );\n    function urns(bytes32 ilk, address urn) external returns (\n        uint256 ink,   // [wad]\n        uint256 art    // [wad]\n    );\n    function debt() external returns (uint256);\n    function move(address src, address dst, uint256 rad) external;\n    function hope(address) external;\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\n    function suck(address u, address v, uint256 rad) external;\n    function cage() external;\n}\n\ninterface CatLike {\n    function ilks(bytes32) external returns (\n        address flip,\n        uint256 chop,  // [ray]\n        uint256 lump   // [rad]\n    );\n    function cage() external;\n}\n\ninterface DogLike {\n    function ilks(bytes32) external returns (\n        address clip,\n        uint256 chop,\n        uint256 hole,\n        uint256 dirt\n    );\n    function cage() external;\n}\n\ninterface PotLike {\n    function cage() external;\n}\n\ninterface VowLike {\n    function cage() external;\n}\n\ninterface FlipLike {\n    function bids(uint256 id) external view returns (\n        uint256 bid,   // [rad]\n        uint256 lot,   // [wad]\n        address guy,\n        uint48  tic,   // [unix epoch time]\n        uint48  end,   // [unix epoch time]\n        address usr,\n        address gal,\n        uint256 tab    // [rad]\n    );\n    function yank(uint256 id) external;\n}\n\ninterface ClipLike {\n    function sales(uint256 id) external view returns (\n        uint256 pos,\n        uint256 tab,\n        uint256 lot,\n        address usr,\n        uint96  tic,\n        uint256 top\n    );\n    function yank(uint256 id) external;\n}\n\ninterface PipLike {\n    function read() external view returns (bytes32);\n}\n\ninterface SpotLike {\n    function par() external view returns (uint256);\n    function ilks(bytes32) external view returns (\n        PipLike pip,\n        uint256 mat    // [ray]\n    );\n    function cage() external;\n}\n\ninterface CureLike {\n    function tell() external view returns (uint256);\n    function cage() external;\n}\n\n/*\n    This is the `End` and it coordinates Global Settlement. This is an\n    involved, stateful process that takes place over nine steps.\n\n    First we freeze the system and lock the prices for each ilk.\n\n    1. `cage()`:\n        - freezes user entrypoints\n        - cancels flop/flap auctions\n        - starts cooldown period\n        - stops pot drips\n\n    2. `cage(ilk)`:\n       - set the cage price for each `ilk`, reading off the price feed\n\n    We must process some system state before it is possible to calculate\n    the final dai / collateral price. In particular, we need to determine\n\n      a. `gap`, the collateral shortfall per collateral type by\n         considering under-collateralised CDPs.\n\n      b. `debt`, the outstanding dai supply after including system\n         surplus / deficit\n\n    We determine (a) by processing all under-collateralised CDPs with\n    `skim`:\n\n    3. `skim(ilk, urn)`:\n       - cancels CDP debt\n       - any excess collateral remains\n       - backing collateral taken\n\n    We determine (b) by processing ongoing dai generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further dai income.\n\n    In the two-way auction model (Flipper) this occurs when\n    all auctions are in the reverse (`dent`) phase. There are two ways\n    of ensuring this:\n\n    4a. i) `wait`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           cage administrator.\n\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of dai.\n\n       ii) `skip`: cancel all ongoing auctions and seize the collateral.\n\n           This allows for faster processing at the expense of more\n           processing calls. This option allows dai holders to retrieve\n           their collateral faster.\n\n           `skip(ilk, id)`:\n            - cancel individual flip auctions in the `tend` (forward) phase\n            - retrieves collateral and debt (including penalty) to owner's CDP\n            - returns dai to last bidder\n            - `dent` (reverse) phase auctions can continue normally\n\n    Option (i), `wait`, is sufficient (if all auctions were bidded at least\n    once) for processing the system settlement but option (ii), `skip`,\n    will speed it up. Both options are available in this implementation,\n    with `skip` being enabled on a per-auction basis.\n\n    In the case of the Dutch Auctions model (Clipper) they keep recovering\n    debt during the whole lifetime and there isn't a max duration time\n    guaranteed for the auction to end.\n    So the way to ensure the protocol will not receive extra dai income is:\n\n    4b. i) `snip`: cancel all ongoing auctions and seize the collateral.\n\n           `snip(ilk, id)`:\n            - cancel individual running clip auctions\n            - retrieves remaining collateral and debt (including penalty)\n              to owner's CDP\n\n    When a CDP has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n\n    5. `free(ilk)`:\n        - remove collateral from the caller's CDP\n        - owner can call as needed\n\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n\n    6. `thaw()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised CDPs are processed\n       - fixes the total outstanding supply of dai\n       - may also require extra CDP processing to cover vow surplus\n\n    7. `flow(ilk)`:\n        - calculate the `fix`, the cash price for a given ilk\n        - adjusts the `fix` in the case of deficit / surplus\n\n    At this point we have computed the final price for each collateral\n    type and dai holders can now turn their dai into collateral. Each\n    unit dai can claim a fixed basket of collateral.\n\n    Dai holders must first `pack` some dai into a `bag`. Once packed,\n    dai cannot be unpacked and is not transferrable. More dai can be\n    added to a bag later.\n\n    8. `pack(wad)`:\n        - put some dai into a bag in preparation for `cash`\n\n    Finally, collateral can be obtained with `cash`. The bigger the bag,\n    the more collateral can be released.\n\n    9. `cash(ilk, wad)`:\n        - exchange some dai from your bag for gems from a specific ilk\n        - the number of gems is limited by how big your bag is\n*/\n\ncontract End {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"End/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    VatLike  public vat;   // CDP Engine\n    CatLike  public cat;\n    DogLike  public dog;\n    VowLike  public vow;   // Debt Engine\n    PotLike  public pot;\n    SpotLike public spot;\n    CureLike public cure;\n\n    uint256  public live;  // Active Flag\n    uint256  public when;  // Time of cage                   [unix epoch time]\n    uint256  public wait;  // Processing Cooldown Length             [seconds]\n    uint256  public debt;  // Total outstanding dai following processing [rad]\n\n    mapping (bytes32 => uint256) public tag;  // Cage price              [ray]\n    mapping (bytes32 => uint256) public gap;  // Collateral shortfall    [wad]\n    mapping (bytes32 => uint256) public Art;  // Total debt per ilk      [wad]\n    mapping (bytes32 => uint256) public fix;  // Final cash price        [ray]\n\n    mapping (address => uint256)                      public bag;  //    [wad]\n    mapping (bytes32 => mapping (address => uint256)) public out;  //    [wad]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed what, address data);\n\n    event Cage();\n    event Cage(bytes32 indexed ilk);\n    event Snip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\n    event Skip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\n    event Skim(bytes32 indexed ilk, address indexed urn, uint256 wad, uint256 art);\n    event Free(bytes32 indexed ilk, address indexed usr, uint256 ink);\n    event Thaw();\n    event Flow(bytes32 indexed ilk);\n    event Pack(address indexed usr, uint256 wad);\n    event Cash(bytes32 indexed ilk, address indexed usr, uint256 wad);\n\n    // --- Init ---\n    constructor() public {\n        wards[msg.sender] = 1;\n        live = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = mul(x, y) / RAY;\n    }\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = mul(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) external auth {\n        require(live == 1, \"End/not-live\");\n        if (what == \"vat\")  vat = VatLike(data);\n        else if (what == \"cat\")   cat = CatLike(data);\n        else if (what == \"dog\")   dog = DogLike(data);\n        else if (what == \"vow\")   vow = VowLike(data);\n        else if (what == \"pot\")   pot = PotLike(data);\n        else if (what == \"spot\") spot = SpotLike(data);\n        else if (what == \"cure\") cure = CureLike(data);\n        else revert(\"End/file-unrecognized-param\");\n        emit File(what, data);\n    }\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"End/not-live\");\n        if (what == \"wait\") wait = data;\n        else revert(\"End/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Settlement ---\n    function cage() external auth {\n        require(live == 1, \"End/not-live\");\n        live = 0;\n        when = block.timestamp;\n        vat.cage();\n        cat.cage();\n        dog.cage();\n        vow.cage();\n        spot.cage();\n        pot.cage();\n        cure.cage();\n        emit Cage();\n    }\n\n    function cage(bytes32 ilk) external {\n        require(live == 0, \"End/still-live\");\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\n        (Art[ilk],,,,) = vat.ilks(ilk);\n        (PipLike pip,) = spot.ilks(ilk);\n        // par is a ray, pip returns a wad\n        tag[ilk] = wdiv(spot.par(), uint256(pip.read()));\n        emit Cage(ilk);\n    }\n\n    function snip(bytes32 ilk, uint256 id) external {\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n\n        (address _clip,,,) = dog.ilks(ilk);\n        ClipLike clip = ClipLike(_clip);\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        (, uint256 tab, uint256 lot, address usr,,) = clip.sales(id);\n\n        vat.suck(address(vow), address(vow),  tab);\n        clip.yank(id);\n\n        uint256 art = tab / rate;\n        Art[ilk] = add(Art[ilk], art);\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\n        emit Snip(ilk, id, usr, tab, lot, art);\n    }\n\n    function skip(bytes32 ilk, uint256 id) external {\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n\n        (address _flip,,) = cat.ilks(ilk);\n        FlipLike flip = FlipLike(_flip);\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        (uint256 bid, uint256 lot,,,, address usr,, uint256 tab) = flip.bids(id);\n\n        vat.suck(address(vow), address(vow),  tab);\n        vat.suck(address(vow), address(this), bid);\n        vat.hope(address(flip));\n        flip.yank(id);\n\n        uint256 art = tab / rate;\n        Art[ilk] = add(Art[ilk], art);\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\n        emit Skip(ilk, id, usr, tab, lot, art);\n    }\n\n    function skim(bytes32 ilk, address urn) external {\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n\n        uint256 owe = rmul(rmul(art, rate), tag[ilk]);\n        uint256 wad = min(ink, owe);\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\n\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\n        vat.grab(ilk, urn, address(this), address(vow), -int256(wad), -int256(art));\n        emit Skim(ilk, urn, wad, art);\n    }\n\n    function free(bytes32 ilk) external {\n        require(live == 0, \"End/still-live\");\n        (uint256 ink, uint256 art) = vat.urns(ilk, msg.sender);\n        require(art == 0, \"End/art-not-zero\");\n        require(ink <= 2**255, \"End/overflow\");\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int256(ink), 0);\n        emit Free(ilk, msg.sender, ink);\n    }\n\n    function thaw() external {\n        require(live == 0, \"End/still-live\");\n        require(debt == 0, \"End/debt-not-zero\");\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\n        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\n        debt = sub(vat.debt(), cure.tell());\n        emit Thaw();\n    }\n    function flow(bytes32 ilk) external {\n        require(debt != 0, \"End/debt-zero\");\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\n\n        (, uint256 rate,,,) = vat.ilks(ilk);\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\n        fix[ilk] = mul(sub(wad, gap[ilk]), RAY) / (debt / RAY);\n        emit Flow(ilk);\n    }\n\n    function pack(uint256 wad) external {\n        require(debt != 0, \"End/debt-zero\");\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\n        bag[msg.sender] = add(bag[msg.sender], wad);\n        emit Pack(msg.sender, wad);\n    }\n    function cash(bytes32 ilk, uint256 wad) external {\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\n        emit Cash(ilk, msg.sender, wad);\n    }\n}\n"
    },
    "contracts/flap.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// flap.sol -- Surplus auction\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2022 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface VatLike {\n    function move(address,address,uint) external;\n}\ninterface GemLike {\n    function move(address,address,uint) external;\n    function burn(address,uint) external;\n}\n\n/*\n   This thing lets you sell some dai in return for gems.\n\n - `lot` dai in return for bid\n - `bid` gems paid\n - `ttl` single bid lifetime\n - `beg` minimum bid increase\n - `end` max auction duration\n*/\n\ncontract Flapper {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Flapper/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        uint256 bid;  // gems paid               [wad]\n        uint256 lot;  // dai in return for bid   [rad]\n        address guy;  // high bidder\n        uint48  tic;  // bid expiry time         [unix epoch time]\n        uint48  end;  // auction expiry time     [unix epoch time]\n    }\n\n    mapping (uint => Bid) public bids;\n\n    VatLike  public   vat;  // CDP Engine\n    GemLike  public   gem;\n\n    uint256  constant ONE = 1.00E18;\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\n    uint48   public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\n    uint256  public kicks = 0;\n    uint256  public live;  // Active Flag\n    uint256  public lid;   // max dai to be in auction at one time  [rad]\n    uint256  public fill;  // current dai in auction                [rad]\n\n    // --- Events ---\n    event Kick(\n      uint256 id,\n      uint256 lot,\n      uint256 bid\n    );\n\n    // --- Init ---\n    constructor(address vat_, address gem_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        gem = GemLike(gem_);\n        live = 1;\n    }\n\n    // --- Math ---\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function add256(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Admin ---\n    function file(bytes32 what, uint data) external auth {\n        if (what == \"beg\") beg = data;\n        else if (what == \"ttl\") ttl = uint48(data);\n        else if (what == \"tau\") tau = uint48(data);\n        else if (what == \"lid\") lid = data;\n        else revert(\"Flapper/file-unrecognized-param\");\n    }\n\n    // --- Auction ---\n    function kick(uint lot, uint bid) external auth returns (uint id) {\n        require(live == 1, \"Flapper/not-live\");\n        require(kicks < uint(-1), \"Flapper/overflow\");\n        fill = add256(fill, lot);\n        require(fill <= lid, \"Flapper/over-lid\");\n        id = ++kicks;\n\n        bids[id].bid = bid;\n        bids[id].lot = lot;\n        bids[id].guy = msg.sender;  // configurable??\n        bids[id].end = add(uint48(now), tau);\n\n        vat.move(msg.sender, address(this), lot);\n\n        emit Kick(id, lot, bid);\n    }\n    function tick(uint id) external {\n        require(bids[id].end < now, \"Flapper/not-finished\");\n        require(bids[id].tic == 0, \"Flapper/bid-already-placed\");\n        bids[id].end = add(uint48(now), tau);\n    }\n    function tend(uint id, uint lot, uint bid) external {\n        require(live == 1, \"Flapper/not-live\");\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flapper/already-finished-tic\");\n        require(bids[id].end > now, \"Flapper/already-finished-end\");\n\n        require(lot == bids[id].lot, \"Flapper/lot-not-matching\");\n        require(bid >  bids[id].bid, \"Flapper/bid-not-higher\");\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid), \"Flapper/insufficient-increase\");\n\n        if (msg.sender != bids[id].guy) {\n            gem.move(msg.sender, bids[id].guy, bids[id].bid);\n            bids[id].guy = msg.sender;\n        }\n        gem.move(msg.sender, address(this), bid - bids[id].bid);\n\n        bids[id].bid = bid;\n        bids[id].tic = add(uint48(now), ttl);\n    }\n    function deal(uint id) external {\n        require(live == 1, \"Flapper/not-live\");\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flapper/not-finished\");\n        uint256 lot = bids[id].lot;\n        vat.move(address(this), bids[id].guy, lot);\n        gem.burn(address(this), bids[id].bid);\n        delete bids[id];\n        fill = sub(fill, lot);\n    }\n\n    function cage(uint rad) external auth {\n       live = 0;\n       vat.move(address(this), msg.sender, rad);\n    }\n    function yank(uint id) external {\n        require(live == 0, \"Flapper/still-live\");\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\n        gem.move(address(this), bids[id].guy, bids[id].bid);\n        delete bids[id];\n    }\n}\n"
    },
    "contracts/flip.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// flip.sol -- Collateral auction\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface VatLike {\n    function move(address,address,uint256) external;\n    function flux(bytes32,address,address,uint256) external;\n}\n\ninterface CatLike {\n    function claw(uint256) external;\n}\n\n/*\n   This thing lets you flip some gems for a given amount of dai.\n   Once the given amount of dai is raised, gems are forgone instead.\n\n - `lot` gems in return for bid\n - `tab` total dai wanted\n - `bid` dai paid\n - `gal` receives dai income\n - `usr` receives gem forgone\n - `ttl` single bid lifetime\n - `beg` minimum bid increase\n - `end` max auction duration\n*/\n\ncontract Flipper {\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Flipper/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        uint256 bid;  // dai paid                 [rad]\n        uint256 lot;  // gems in return for bid   [wad]\n        address guy;  // high bidder\n        uint48  tic;  // bid expiry time          [unix epoch time]\n        uint48  end;  // auction expiry time      [unix epoch time]\n        address usr;\n        address gal;\n        uint256 tab;  // total dai wanted         [rad]\n    }\n\n    mapping (uint256 => Bid) public bids;\n\n    VatLike public   vat;            // CDP Engine\n    bytes32 public   ilk;            // collateral type\n\n    uint256 constant ONE = 1.00E18;\n    uint256 public   beg = 1.05E18;  // 5% minimum bid increase\n    uint48  public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\n    uint48  public   tau = 2 days;   // 2 days total auction length  [seconds]\n    uint256 public kicks = 0;\n    CatLike public   cat;            // cat liquidation module\n\n    // --- Events ---\n    event Kick(\n      uint256 id,\n      uint256 lot,\n      uint256 bid,\n      uint256 tab,\n      address indexed usr,\n      address indexed gal\n    );\n\n    // --- Init ---\n    constructor(address vat_, address cat_, bytes32 ilk_) public {\n        vat = VatLike(vat_);\n        cat = CatLike(cat_);\n        ilk = ilk_;\n        wards[msg.sender] = 1;\n    }\n\n    // --- Math ---\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Admin ---\n    function file(bytes32 what, uint256 data) external auth {\n        if (what == \"beg\") beg = data;\n        else if (what == \"ttl\") ttl = uint48(data);\n        else if (what == \"tau\") tau = uint48(data);\n        else revert(\"Flipper/file-unrecognized-param\");\n    }\n    function file(bytes32 what, address data) external auth {\n        if (what == \"cat\") cat = CatLike(data);\n        else revert(\"Flipper/file-unrecognized-param\");\n    }\n\n    // --- Auction ---\n    function kick(address usr, address gal, uint256 tab, uint256 lot, uint256 bid)\n        public auth returns (uint256 id)\n    {\n        require(kicks < uint256(-1), \"Flipper/overflow\");\n        id = ++kicks;\n\n        bids[id].bid = bid;\n        bids[id].lot = lot;\n        bids[id].guy = msg.sender;  // configurable??\n        bids[id].end = add(uint48(now), tau);\n        bids[id].usr = usr;\n        bids[id].gal = gal;\n        bids[id].tab = tab;\n\n        vat.flux(ilk, msg.sender, address(this), lot);\n\n        emit Kick(id, lot, bid, tab, usr, gal);\n    }\n    function tick(uint256 id) external {\n        require(bids[id].end < now, \"Flipper/not-finished\");\n        require(bids[id].tic == 0, \"Flipper/bid-already-placed\");\n        bids[id].end = add(uint48(now), tau);\n    }\n    function tend(uint256 id, uint256 lot, uint256 bid) external {\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\n\n        require(lot == bids[id].lot, \"Flipper/lot-not-matching\");\n        require(bid <= bids[id].tab, \"Flipper/higher-than-tab\");\n        require(bid >  bids[id].bid, \"Flipper/bid-not-higher\");\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid) || bid == bids[id].tab, \"Flipper/insufficient-increase\");\n\n        if (msg.sender != bids[id].guy) {\n            vat.move(msg.sender, bids[id].guy, bids[id].bid);\n            bids[id].guy = msg.sender;\n        }\n        vat.move(msg.sender, bids[id].gal, bid - bids[id].bid);\n\n        bids[id].bid = bid;\n        bids[id].tic = add(uint48(now), ttl);\n    }\n    function dent(uint256 id, uint256 lot, uint256 bid) external {\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\n\n        require(bid == bids[id].bid, \"Flipper/not-matching-bid\");\n        require(bid == bids[id].tab, \"Flipper/tend-not-finished\");\n        require(lot < bids[id].lot, \"Flipper/lot-not-lower\");\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flipper/insufficient-decrease\");\n\n        if (msg.sender != bids[id].guy) {\n            vat.move(msg.sender, bids[id].guy, bid);\n            bids[id].guy = msg.sender;\n        }\n        vat.flux(ilk, address(this), bids[id].usr, bids[id].lot - lot);\n\n        bids[id].lot = lot;\n        bids[id].tic = add(uint48(now), ttl);\n    }\n    function deal(uint256 id) external {\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flipper/not-finished\");\n        cat.claw(bids[id].tab);\n        vat.flux(ilk, address(this), bids[id].guy, bids[id].lot);\n        delete bids[id];\n    }\n\n    function yank(uint256 id) external auth {\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\n        require(bids[id].bid < bids[id].tab, \"Flipper/already-dent-phase\");\n        cat.claw(bids[id].tab);\n        vat.flux(ilk, address(this), msg.sender, bids[id].lot);\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\n        delete bids[id];\n    }\n}\n"
    },
    "contracts/flop.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// flop.sol -- Debt auction\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface VatLike {\n    function move(address,address,uint) external;\n    function suck(address,address,uint) external;\n}\ninterface GemLike {\n    function mint(address,uint) external;\n}\ninterface VowLike {\n    function Ash() external returns (uint);\n    function kiss(uint) external;\n}\n\n/*\n   This thing creates gems on demand in return for dai.\n\n - `lot` gems in return for bid\n - `bid` dai paid\n - `gal` receives dai income\n - `ttl` single bid lifetime\n - `beg` minimum bid increase\n - `end` max auction duration\n*/\n\ncontract Flopper {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Flopper/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        uint256 bid;  // dai paid                [rad]\n        uint256 lot;  // gems in return for bid  [wad]\n        address guy;  // high bidder\n        uint48  tic;  // bid expiry time         [unix epoch time]\n        uint48  end;  // auction expiry time     [unix epoch time]\n    }\n\n    mapping (uint => Bid) public bids;\n\n    VatLike  public   vat;  // CDP Engine\n    GemLike  public   gem;\n\n    uint256  constant ONE = 1.00E18;\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime         [seconds]\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\n    uint256  public kicks = 0;\n    uint256  public live;             // Active Flag\n    address  public vow;              // not used until shutdown\n\n    // --- Events ---\n    event Kick(\n      uint256 id,\n      uint256 lot,\n      uint256 bid,\n      address indexed gal\n    );\n\n    // --- Init ---\n    constructor(address vat_, address gem_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        gem = GemLike(gem_);\n        live = 1;\n    }\n\n    // --- Math ---\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function min(uint x, uint y) internal pure returns (uint z) {\n        if (x > y) { z = y; } else { z = x; }\n    }\n\n    // --- Admin ---\n    function file(bytes32 what, uint data) external auth {\n        if (what == \"beg\") beg = data;\n        else if (what == \"pad\") pad = data;\n        else if (what == \"ttl\") ttl = uint48(data);\n        else if (what == \"tau\") tau = uint48(data);\n        else revert(\"Flopper/file-unrecognized-param\");\n    }\n\n    // --- Auction ---\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\n        require(live == 1, \"Flopper/not-live\");\n        require(kicks < uint(-1), \"Flopper/overflow\");\n        id = ++kicks;\n\n        bids[id].bid = bid;\n        bids[id].lot = lot;\n        bids[id].guy = gal;\n        bids[id].end = add(uint48(now), tau);\n\n        emit Kick(id, lot, bid, gal);\n    }\n    function tick(uint id) external {\n        require(bids[id].end < now, \"Flopper/not-finished\");\n        require(bids[id].tic == 0, \"Flopper/bid-already-placed\");\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\n        bids[id].end = add(uint48(now), tau);\n    }\n    function dent(uint id, uint lot, uint bid) external {\n        require(live == 1, \"Flopper/not-live\");\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flopper/already-finished-tic\");\n        require(bids[id].end > now, \"Flopper/already-finished-end\");\n\n        require(bid == bids[id].bid, \"Flopper/not-matching-bid\");\n        require(lot <  bids[id].lot, \"Flopper/lot-not-lower\");\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flopper/insufficient-decrease\");\n\n        if (msg.sender != bids[id].guy) {\n            vat.move(msg.sender, bids[id].guy, bid);\n\n            // on first dent, clear as much Ash as possible\n            if (bids[id].tic == 0) {\n                uint Ash = VowLike(bids[id].guy).Ash();\n                VowLike(bids[id].guy).kiss(min(bid, Ash));\n            }\n\n            bids[id].guy = msg.sender;\n        }\n\n        bids[id].lot = lot;\n        bids[id].tic = add(uint48(now), ttl);\n    }\n    function deal(uint id) external {\n        require(live == 1, \"Flopper/not-live\");\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flopper/not-finished\");\n        gem.mint(bids[id].guy, bids[id].lot);\n        delete bids[id];\n    }\n\n    // --- Shutdown ---\n    function cage() external auth {\n       live = 0;\n       vow = msg.sender;\n    }\n    function yank(uint id) external {\n        require(live == 0, \"Flopper/still-live\");\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\n        vat.suck(vow, bids[id].guy, bids[id].bid);\n        delete bids[id];\n    }\n}\n"
    },
    "contracts/join.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// join.sol -- Basic token adapters\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface GemLike {\n    function decimals() external view returns (uint);\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n}\n\ninterface DSTokenLike {\n    function mint(address,uint) external;\n    function burn(address,uint) external;\n}\n\ninterface VatLike {\n    function slip(bytes32,address,int) external;\n    function move(address,address,uint) external;\n}\n\n/*\n    Here we provide *adapters* to connect the Vat to arbitrary external\n    token implementations, creating a bounded context for the Vat. The\n    adapters here are provided as working examples:\n\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\n                   semantics.\n\n      - `ETHJoin`: For native Ether.\n\n      - `DaiJoin`: For connecting internal Dai balances to an external\n                   `DSToken` implementation.\n\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n\n    Adapters need to implement two basic methods:\n\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n\n*/\n\ncontract GemJoin {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;   // CDP Engine\n    bytes32 public ilk;   // Collateral Type\n    GemLike public gem;\n    uint    public dec;\n    uint    public live;  // Active Flag\n\n    // Events\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n    event Cage();\n\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        ilk = ilk_;\n        gem = GemLike(gem_);\n        dec = gem.decimals();\n        emit Rely(msg.sender);\n    }\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n    function join(address usr, uint wad) external {\n        require(live == 1, \"GemJoin/not-live\");\n        require(int(wad) >= 0, \"GemJoin/overflow\");\n        vat.slip(ilk, usr, int(wad));\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\n        emit Join(usr, wad);\n    }\n    function exit(address usr, uint wad) external {\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\n        vat.slip(ilk, msg.sender, -int(wad));\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\n        emit Exit(usr, wad);\n    }\n}\n\ncontract DaiJoin {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"DaiJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;      // CDP Engine\n    DSTokenLike public dai;  // Stablecoin Token\n    uint    public live;     // Active Flag\n\n    // Events\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Join(address indexed usr, uint256 wad);\n    event Exit(address indexed usr, uint256 wad);\n    event Cage();\n\n    constructor(address vat_, address dai_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        dai = DSTokenLike(dai_);\n    }\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function join(address usr, uint wad) external {\n        vat.move(address(this), usr, mul(ONE, wad));\n        dai.burn(msg.sender, wad);\n        emit Join(usr, wad);\n    }\n    function exit(address usr, uint wad) external {\n        require(live == 1, \"DaiJoin/not-live\");\n        vat.move(msg.sender, address(this), mul(ONE, wad));\n        dai.mint(usr, wad);\n        emit Exit(usr, wad);\n    }\n}\n"
    },
    "contracts/jug.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// jug.sol -- Dai Lending Rate\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface VatLike {\n    function ilks(bytes32) external returns (\n        uint256 Art,   // [wad]\n        uint256 rate   // [ray]\n    );\n    function fold(bytes32,address,int) external;\n}\n\ncontract Jug {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Jug/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint256 duty;  // Collateral-specific, per-second stability fee contribution [ray]\n        uint256  rho;  // Time of last drip [unix epoch time]\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n    VatLike                  public vat;   // CDP Engine\n    address                  public vow;   // Debt Engine\n    uint256                  public base;  // Global, per-second stability fee contribution [ray]\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n    }\n\n    // --- Math ---\n    function _rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n      assembly {\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n        default {\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n          let half := div(b, 2)  // for rounding.\n          for { n := div(n, 2) } n { n := div(n,2) } {\n            let xx := mul(x, x)\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n            let xxRound := add(xx, half)\n            if lt(xxRound, xx) { revert(0,0) }\n            x := div(xxRound, b)\n            if mod(n,2) {\n              let zx := mul(z, x)\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n              let zxRound := add(zx, half)\n              if lt(zxRound, zx) { revert(0,0) }\n              z := div(zxRound, b)\n            }\n          }\n        }\n      }\n    }\n    uint256 constant ONE = 10 ** 27;\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function _diff(uint x, uint y) internal pure returns (int z) {\n        z = int(x) - int(y);\n        require(int(x) >= 0 && int(y) >= 0);\n    }\n    function _rmul(uint x, uint y) internal pure returns (uint z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / ONE;\n    }\n\n    // --- Administration ---\n    function init(bytes32 ilk) external auth {\n        Ilk storage i = ilks[ilk];\n        require(i.duty == 0, \"Jug/ilk-already-init\");\n        i.duty = ONE;\n        i.rho  = now;\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n        if (what == \"duty\") ilks[ilk].duty = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n    function file(bytes32 what, uint data) external auth {\n        if (what == \"base\") base = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n    function file(bytes32 what, address data) external auth {\n        if (what == \"vow\") vow = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n\n    // --- Stability Fee Collection ---\n    function drip(bytes32 ilk) external returns (uint rate) {\n        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\n        (, uint prev) = vat.ilks(ilk);\n        rate = _rmul(_rpow(_add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\n        vat.fold(ilk, vow, _diff(rate, prev));\n        ilks[ilk].rho = now;\n    }\n}\n"
    },
    "contracts/pot.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// pot.sol -- Dai Savings Rate\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\n/*\n   \"Savings Dai\" is obtained when Dai is deposited into\n   this contract. Each \"Savings Dai\" accrues Dai interest\n   at the \"Dai Savings Rate\".\n\n   This contract does not implement a user tradeable token\n   and is intended to be used with adapters.\n\n         --- `save` your `dai` in the `pot` ---\n\n   - `dsr`: the Dai Savings Rate\n   - `pie`: user balance of Savings Dai\n\n   - `join`: start saving some dai\n   - `exit`: remove some dai\n   - `drip`: perform rate collection\n\n*/\n\ninterface VatLike {\n    function move(address,address,uint256) external;\n    function suck(address,address,uint256) external;\n}\n\ncontract Pot {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external auth { wards[guy] = 1; }\n    function deny(address guy) external auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Pot/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    mapping (address => uint256) public pie;  // Normalised Savings Dai [wad]\n\n    uint256 public Pie;   // Total Normalised Savings Dai  [wad]\n    uint256 public dsr;   // The Dai Savings Rate          [ray]\n    uint256 public chi;   // The Rate Accumulator          [ray]\n\n    VatLike public vat;   // CDP Engine\n    address public vow;   // Debt Engine\n    uint256 public rho;   // Time of last drip     [unix epoch time]\n\n    uint256 public live;  // Active Flag\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        dsr = ONE;\n        chi = ONE;\n        rho = now;\n        live = 1;\n    }\n\n    // --- Math ---\n    uint256 constant ONE = 10 ** 27;\n    function _rpow(uint x, uint n, uint base) internal pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function _rmul(uint x, uint y) internal pure returns (uint z) {\n        z = _mul(x, y) / ONE;\n    }\n\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function _mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Pot/not-live\");\n        require(now == rho, \"Pot/rho-not-updated\");\n        if (what == \"dsr\") dsr = data;\n        else revert(\"Pot/file-unrecognized-param\");\n    }\n\n    function file(bytes32 what, address addr) external auth {\n        if (what == \"vow\") vow = addr;\n        else revert(\"Pot/file-unrecognized-param\");\n    }\n\n    function cage() external auth {\n        live = 0;\n        dsr = ONE;\n    }\n\n    // --- Savings Rate Accumulation ---\n    function drip() external returns (uint tmp) {\n        require(now >= rho, \"Pot/invalid-now\");\n        tmp = _rmul(_rpow(dsr, now - rho, ONE), chi);\n        uint chi_ = _sub(tmp, chi);\n        chi = tmp;\n        rho = now;\n        vat.suck(address(vow), address(this), _mul(Pie, chi_));\n    }\n\n    // --- Savings Dai Management ---\n    function join(uint wad) external {\n        require(now == rho, \"Pot/rho-not-updated\");\n        pie[msg.sender] = _add(pie[msg.sender], wad);\n        Pie             = _add(Pie,             wad);\n        vat.move(msg.sender, address(this), _mul(chi, wad));\n    }\n\n    function exit(uint wad) external {\n        pie[msg.sender] = _sub(pie[msg.sender], wad);\n        Pie             = _sub(Pie,             wad);\n        vat.move(address(this), msg.sender, _mul(chi, wad));\n    }\n}\n"
    },
    "contracts/spot.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// spot.sol -- Spotter\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface VatLike {\n    function file(bytes32, bytes32, uint) external;\n}\n\ninterface PipLike {\n    function peek() external returns (bytes32, bool);\n}\n\ncontract Spotter {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external auth { wards[guy] = 1;  }\n    function deny(address guy) external auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Spotter/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        PipLike pip;  // Price Feed\n        uint256 mat;  // Liquidation ratio [ray]\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    VatLike public vat;  // CDP Engine\n    uint256 public par;  // ref per dai [ray]\n\n    uint256 public live;\n\n    // --- Events ---\n    event Poke(\n      bytes32 ilk,\n      bytes32 val,  // [wad]\n      uint256 spot  // [ray]\n    );\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        par = ONE;\n        live = 1;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = mul(x, ONE) / y;\n    }\n\n    // --- Administration ---\n    function file(bytes32 ilk, bytes32 what, address pip_) external auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"pip\") ilks[ilk].pip = PipLike(pip_);\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n    function file(bytes32 what, uint data) external auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"par\") par = data;\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"mat\") ilks[ilk].mat = data;\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n\n    // --- Update value ---\n    function poke(bytes32 ilk) external {\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\n        vat.file(ilk, \"spot\", spot);\n        emit Poke(ilk, val, spot);\n    }\n\n    function cage() external auth {\n        live = 0;\n    }\n}\n"
    },
    "contracts/vat.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// vat.sol -- Dai CDP database\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ncontract Vat {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 1; }\n    function deny(address usr) external auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    mapping(address => mapping (address => uint)) public can;\n    function hope(address usr) external { can[msg.sender][usr] = 1; }\n    function nope(address usr) external { can[msg.sender][usr] = 0; }\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n    mapping (address => uint256)                   public dai;  // [rad]\n    mapping (address => uint256)                   public sin;  // [rad]\n\n    uint256 public debt;  // Total Dai Issued    [rad]\n    uint256 public vice;  // Total Unbacked Dai  [rad]\n    uint256 public Line;  // Total Debt Ceiling  [rad]\n    uint256 public live;  // Active Flag\n\n    // --- Init ---\n    constructor() public {\n        wards[msg.sender] = 1;\n        live = 1;\n    }\n\n    // --- Math ---\n    function _add(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function _sub(uint x, int y) internal pure returns (uint z) {\n        z = x - uint(y);\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function _mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n    function _add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function _sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function _mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function init(bytes32 ilk) external auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n    }\n    function file(bytes32 what, uint data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function cage() external auth {\n        live = 0;\n    }\n\n    // --- Fungibility ---\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\n    }\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = _sub(gem[ilk][src], wad);\n        gem[ilk][dst] = _add(gem[ilk][dst], wad);\n    }\n    function move(address src, address dst, uint256 rad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = _sub(dai[src], rad);\n        dai[dst] = _add(dai[dst], rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- CDP Manipulation ---\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external {\n        // system is live\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        // ilk has been initialised\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int dtab = _mul(ilk.rate, dart);\n        uint tab = _mul(ilk.rate, urn.art);\n        debt     = _add(debt, dtab);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(dart <= 0, both(_mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        // urn is either less risky than before, or it is safe\n        require(either(both(dart <= 0, dink >= 0), tab <= _mul(urn.ink, ilk.spot)), \"Vat/not-safe\");\n\n        // urn is either more safe, or the owner consents\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        // collateral src consents\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        // debt dst consents\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        // urn has no debt, or a non-dusty amount\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        dai[w]    = _add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n    }\n    // --- CDP Fungibility ---\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = _sub(u.ink, dink);\n        u.art = _sub(u.art, dart);\n        v.ink = _add(v.ink, dink);\n        v.art = _add(v.art, dart);\n\n        uint utab = _mul(u.art, i.rate);\n        uint vtab = _mul(v.art, i.rate);\n\n        // both sides consent\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        // both sides safe\n        require(utab <= _mul(u.ink, i.spot), \"Vat/not-safe-src\");\n        require(vtab <= _mul(v.ink, i.spot), \"Vat/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n    }\n    // --- CDP Confiscation ---\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int dtab = _mul(ilk.rate, dart);\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        sin[w]    = _sub(sin[w],    dtab);\n        vice      = _sub(vice,      dtab);\n    }\n\n    // --- Settlement ---\n    function heal(uint rad) external {\n        address u = msg.sender;\n        sin[u] = _sub(sin[u], rad);\n        dai[u] = _sub(dai[u], rad);\n        vice   = _sub(vice,   rad);\n        debt   = _sub(debt,   rad);\n    }\n    function suck(address u, address v, uint rad) external auth {\n        sin[u] = _add(sin[u], rad);\n        dai[v] = _add(dai[v], rad);\n        vice   = _add(vice,   rad);\n        debt   = _add(debt,   rad);\n    }\n\n    // --- Rates ---\n    function fold(bytes32 i, address u, int rate) external auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate = _add(ilk.rate, rate);\n        int rad  = _mul(ilk.Art, rate);\n        dai[u]   = _add(dai[u], rad);\n        debt     = _add(debt,   rad);\n    }\n}\n"
    },
    "contracts/vow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// vow.sol -- Dai settlement module\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.12;\n\n// FIXME: This contract was altered compared to the production version.\n// It doesn't use LibNote anymore.\n// New deployments of this contract will need to include custom events (TO DO).\n\ninterface FlopLike {\n    function kick(address gal, uint lot, uint bid) external returns (uint);\n    function cage() external;\n    function live() external returns (uint);\n}\n\ninterface FlapLike {\n    function kick(uint lot, uint bid) external returns (uint);\n    function cage(uint) external;\n    function live() external returns (uint);\n}\n\ninterface VatLike {\n    function dai (address) external view returns (uint);\n    function sin (address) external view returns (uint);\n    function heal(uint256) external;\n    function hope(address) external;\n    function nope(address) external;\n}\n\ncontract Vow {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external auth { require(live == 1, \"Vow/not-live\"); wards[usr] = 1; }\n    function deny(address usr) external auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vow/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    VatLike public vat;        // CDP Engine\n    FlapLike public flapper;   // Surplus Auction House\n    FlopLike public flopper;   // Debt Auction House\n\n    mapping (uint256 => uint256) public sin;  // debt queue\n    uint256 public Sin;   // Queued debt            [rad]\n    uint256 public Ash;   // On-auction debt        [rad]\n\n    uint256 public wait;  // Flop delay             [seconds]\n    uint256 public dump;  // Flop initial lot size  [wad]\n    uint256 public sump;  // Flop fixed bid size    [rad]\n\n    uint256 public bump;  // Flap fixed lot size    [rad]\n    uint256 public hump;  // Surplus buffer         [rad]\n\n    uint256 public live;  // Active Flag\n\n    // --- Init ---\n    constructor(address vat_, address flapper_, address flopper_) public {\n        wards[msg.sender] = 1;\n        vat     = VatLike(vat_);\n        flapper = FlapLike(flapper_);\n        flopper = FlopLike(flopper_);\n        vat.hope(flapper_);\n        live = 1;\n    }\n\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint data) external auth {\n        if (what == \"wait\") wait = data;\n        else if (what == \"bump\") bump = data;\n        else if (what == \"sump\") sump = data;\n        else if (what == \"dump\") dump = data;\n        else if (what == \"hump\") hump = data;\n        else revert(\"Vow/file-unrecognized-param\");\n    }\n\n    function file(bytes32 what, address data) external auth {\n        if (what == \"flapper\") {\n            vat.nope(address(flapper));\n            flapper = FlapLike(data);\n            vat.hope(data);\n        }\n        else if (what == \"flopper\") flopper = FlopLike(data);\n        else revert(\"Vow/file-unrecognized-param\");\n    }\n\n    // Push to debt-queue\n    function fess(uint tab) external auth {\n        sin[now] = add(sin[now], tab);\n        Sin = add(Sin, tab);\n    }\n    // Pop from debt-queue\n    function flog(uint era) external {\n        require(add(era, wait) <= now, \"Vow/wait-not-finished\");\n        Sin = sub(Sin, sin[era]);\n        sin[era] = 0;\n    }\n\n    // Debt settlement\n    function heal(uint rad) external {\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\n        require(rad <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\n        vat.heal(rad);\n    }\n    function kiss(uint rad) external {\n        require(rad <= Ash, \"Vow/not-enough-ash\");\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\n        Ash = sub(Ash, rad);\n        vat.heal(rad);\n    }\n\n    // Debt auction\n    function flop() external returns (uint id) {\n        require(sump <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\n        require(vat.dai(address(this)) == 0, \"Vow/surplus-not-zero\");\n        Ash = add(Ash, sump);\n        id = flopper.kick(address(this), dump, sump);\n    }\n    // Surplus auction\n    function flap() external returns (uint id) {\n        require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");\n        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");\n        id = flapper.kick(bump, 0);\n    }\n\n    function cage() external auth {\n        require(live == 1, \"Vow/not-live\");\n        live = 0;\n        Sin = 0;\n        Ash = 0;\n        flapper.cage(vat.dai(address(flapper)));\n        flopper.cage();\n        vat.heal(min(vat.dai(address(this)), vat.sin(address(this))));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}